dim(last.plot.coord$edge)[1]
length(ext.node) + 1
plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < length(ext.node)) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}
col.age[counter]
ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}
xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)
start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}
for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}
rm(list=ls(all=TRUE))#
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    phylogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
rm(list=ls(all=TRUE))#
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    phylogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}
if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
phy
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}
plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=1; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=1; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}
plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)
all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]
for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}
if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
rm(list=ls(all=TRUE))#
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		phy$edge.length <- phy$edge.length * time.correction#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
rm(list=ls(all=TRUE))
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=1; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))	#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		phy$edge.length <- phy$edge.length * time.correction#
	}
phy
phy$root.edge
!is.null(mcmc.chain)
phy$root.edge
end.age
phy.matrix[1,1]
!is.null(mcmc.chain)
internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]
end.age
max.ages
max(nodeTimes(phy))
phy$root.edge <- end.age - max(nodeTimes(phy))
end.age
time.correction
time.correction=100
rm(list=ls(all=TRUE))#
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
			phy$root.edge <- end.age - max(nodeTimes(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		phy$edge.length <- phy$edge.length * time.correction#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
hpd.ages
rm(list=ls(all=TRUE))
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=1; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
!is.null(mcmc.chain)
internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}
phy$root.edge
end.age
max(nodeTimes(phy)
max(nodeTimes(phy))
mean.ages[1]
nodeTimes(phy)
rm(list=ls(all=TRUE))#
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			# phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		phy$edge.length <- phy$edge.length * time.correction#
		phy$root.edge <- (end.age * time.correction) - max(nodeTimes(phy))#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.chain=mcmc.chain.in; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=1; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
!is.null(mcmc.chain)
internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))
phy$edge.length
phy$edge.length * time.correction
time.correction
time.correction=100
phy$edge.length <- phy$edge.length * time.correction
(end.age * time.correction)
max(nodeTimes(phy))
(end.age * time.correction) - max(nodeTimes(phy))
phy
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.chain=mcmc.chain.in; plot.type="distribution"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res=c("Eon", "Period"); time.correction=100; col.age="#00008020"; tip.lengths=FALSE; cex.tips=0.33; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=0.4; relative.height=0.08; cex.labels=0.5; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}
if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}
!is.null(mcmc.chain)
internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))
end.age
max.ages
mean.ages
phy$root.edge
end.age
nodeTimes(phy)[1,1]
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
# source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/plot.timescale.R', chdir = TRUE)#
#
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8#
#
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot <- function(phy, mcmc.chain=NULL, plot.type="phylogram", analysis.type="mcmctree", build.tree=FALSE, add.abs.time=TRUE, method="bar", add.time.scale=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, relative.height=0.08, cex.labels=1, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.mb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		directory.rb <- "~/Documents/revbayes.example/output/TimeTree_bears_mcmc_MAP.tre"#
		phy.data <- read.in.revbayes(directory.rb)#
		t.name <- gsub(".con.tre", ".run1.t", directory.mb)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.rb)[[1]])#
			path.to.files <- substring(directory.rb, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/mcmc.tree.plot.R', chdir = TRUE)
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
phy <- read.nexus("/Applications/MrBayes/examples/hymfossil.nex.con.tre")#
directory.mb="/Applications/MrBayes/examples/hymfossil.nex.con.tre"#
tip.bar.col="#ff000050"
phy.edge <- phy$apePhy$edge#
phy <- phy$apePhy#
#
## set up node ages manually#
all.nodes <- as.numeric(gsub("t_n", "", colnames(mcmc.chain)[2:103]))#
mcmc.chain.age <- mcmc.chain[,2:103]#
node.ages <- vector("list", Nnode(phy))#
names(node.ages)[1:Nnode(phy)] <- c(Ntip(phy) +1, phy.edge[which(phy.edge[,2] > Ntip(phy)),2])#
for(uu in 1:length(all.nodes)) 	node.ages[[uu]] <- mcmc.chain.age[,uu]
phy <- read.nexus("/Applications/MrBayes/examples/hymfossil.nex.con.tre")#
directory.mb="/Applications/MrBayes/examples/hymfossil.nex.con.tre"#
tip.bar.col="#ff000050"
#' Plot time-scaled phylogenies#
#'#
#' Plot time-scaled phylogenies with node uncertainty and timescale#
#' @param phy A timescaled phylogeny, unless analysis.type="mcmctree" and build.tree=TRUE#
#' @param analysis.type The method used to generate the time-scale tree, one of mcmctree, MrBayes, RevBayes, or User.#
#' @param mcmc.chain The full posterior of age estimates for all nodes (default NULL)#
#' @param node.ages User-supplied node ages applicable for analysis.type user#
#' @param directory.files The directory for files to summarise for MrBayes and RevBayes analyses#
#' @param plot.type The plotting method for the phylogram corresponding to the APE definition. Phylogram is available for all analysis types, but cladogram is only avilable for mcmctree analyses at present. Type distributions plots a phylogram with density distributions on each of the nodes.#
#' @param build.tree Logical. Only applicable to mcmctree analyses, whether to timescale the phylogeny based on the full mcmc chain#
#' @param node.method For plot.type phylogram the method to dispay age uncertainty on each node, either bar, node.length, or full.length.#
#' @param add.time.scale Logical. Adds a timescale to the plotted phylogeny.#
#' @param add.abs.time Logical. Adds an absolute timescale alongside the geological timescale. Only applicable if add.time.scale is TRUE#
#' @param scale.res The geological age designation to add to the plot#
#' @param time.correction Number to place branch lengths and age estimates in absolute time, deafult to one.#
#' @param col.age The colouring of the node.method bars to summarise node age uncertainty#
#' @param tip.lengths Logical. If the tree contains non-present tip ages, the age uncertainty associated with them will be added to the plot#
#' @param cex.tips Size of the phylogeny tip labels#
#' @param show.tip.label Logical. Should the tree tip labels be displayed#
#' @param col.tree Colour of the phylogeny edges#
#' @param tip.color Colour of the phylogeny tip labels#
#' @param lwd.bar Width of the bar to summarise age uncertainty, applicable only if plot.type is phylogram and node.method is bar#
#' @param grey.bars Logical. Should grey bars be used to signify time bins, applicable only if add.time.scale is TRUE#
#' @param cex.age Size of the labels for the absolute timescale#
#' @param cex.labels Size of the labels for the geological timescale#
#' @param relative.height the relative height of the timescale labels#
#' @param ntrees For analysis.type mrbayes, the number of independent chains to summarise#
#' @param tip.bar.col The colour of uncertainty around non-contemporary tips#
#' @param burn.in The number of points in the chain to discard for MrBayes and RevBayes analyses#
#' @param distribution.height The relative height of node distributions when plot.type is distributions measured as the relative height of the descendent node#
#' @keywords #
#' @return If plot=TRUE plot of distributions in file 'pdfOutput' written to current working directory#
#' @export#
#' @examples#
#' # example#
#
mcmc.tree.plot <- function(phy, analysis.type="mcmctree", mcmc.chain=NULL, node.ages=NULL, directory.files=NULL, plot.type="phylogram", build.tree=FALSE, node.method="bar", add.time.scale=TRUE, add.abs.time=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, cex.labels=1, relative.height=0.08, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.files)#
		t.name <- gsub(".con.tre", ".run1.t", directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		phy.data <- read.in.revbayes(directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(node.method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(node.method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(node.method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(node.method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.files)[[1]])#
			path.to.files <- substring(directory.files, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080")
args(mcmc.tree.plot)
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/mcmc.tree.plot.R', chdir = TRUE)
phy <- read.nexus("/Applications/MrBayes/examples/hymfossil.nex.con.tre")
directory.mb="/Applications/MrBayes/examples/hymfossil.nex.con.tre"
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008020")
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080")
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", edge.col="white")
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.edge="white")
arg(mcmc.tree.plot)
args(mcmc.tree.plot)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="white")
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/time.colour.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.mrbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/read.in.revbayes.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/readMCMCTree.R', chdir = TRUE)#
source('~/Documents/MCMCTreeR_parent/MCMCTreeR/R/mcmc.tree.plot.R', chdir = TRUE)#
#
phy=NULL; mcmc.chain=NULL; plot.type="phylogram"; analysis.type="mcmctree"; build.tree=FALSE; add.abs.time=TRUE; method="bar"; add.time.scale=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; relative.height=0.08; cex.labels=1; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8
phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
mcmc.chain.in <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmc.chain.in, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="white")
########
phy <- read.nexus("/Applications/MrBayes/examples/hymfossil.nex.con.tre")#
directory.mb="/Applications/MrBayes/examples/hymfossil.nex.con.tre"#
tip.bar.col="#ff000050"
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
phy.edge <- phy$apePhy$edge
phy <- phy$apePhy
## set up node ages manually#
all.nodes <- as.numeric(gsub("t_n", "", colnames(mcmc.chain)[2:103]))#
mcmc.chain.age <- mcmc.chain[,2:103]#
node.ages <- vector("list", Nnode(phy))#
names(node.ages)[1:Nnode(phy)] <- c(Ntip(phy) +1, phy.edge[which(phy.edge[,2] > Ntip(phy)),2])#
for(uu in 1:length(all.nodes)) 	node.ages[[uu]] <- mcmc.chain.age[,uu]#
## names(node.ages)[-c(1:Nnode(phy))] <- 1:Ntip(phy)#
## node.ages[-c(1:Nnode(phy))] <- c(0,0)
phy <- read.nexus("/Applications/MrBayes/examples/hymfossil.nex.con.tre")
phy
directory.mb="/Applications/MrBayes/examples/hymfossil.nex.con.tre"
tip.bar.col="#ff000050"
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distribution", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
#' Plot time-scaled phylogenies#
#'#
#' Plot time-scaled phylogenies with node uncertainty and timescale#
#' @param phy A timescaled phylogeny, unless analysis.type="mcmctree" and build.tree=TRUE#
#' @param analysis.type The method used to generate the time-scale tree, one of mcmctree, MrBayes, RevBayes, or User.#
#' @param mcmc.chain The full posterior of age estimates for all nodes (default NULL)#
#' @param node.ages User-supplied node ages applicable for analysis.type user#
#' @param directory.files The directory for files to summarise for MrBayes and RevBayes analyses#
#' @param plot.type The plotting method for the phylogram corresponding to the APE definition. Phylogram is available for all analysis types, but cladogram is only avilable for mcmctree analyses at present. Type distributions plots a phylogram with density distributions on each of the nodes.#
#' @param build.tree Logical. Only applicable to mcmctree analyses, whether to timescale the phylogeny based on the full mcmc chain#
#' @param node.method For plot.type phylogram the method to dispay age uncertainty on each node, either bar, node.length, or full.length.#
#' @param add.time.scale Logical. Adds a timescale to the plotted phylogeny.#
#' @param add.abs.time Logical. Adds an absolute timescale alongside the geological timescale. Only applicable if add.time.scale is TRUE#
#' @param scale.res The geological age designation to add to the plot#
#' @param time.correction Number to place branch lengths and age estimates in absolute time, deafult to one.#
#' @param col.age The colouring of the node.method bars to summarise node age uncertainty#
#' @param tip.lengths Logical. If the tree contains non-present tip ages, the age uncertainty associated with them will be added to the plot#
#' @param cex.tips Size of the phylogeny tip labels#
#' @param show.tip.label Logical. Should the tree tip labels be displayed#
#' @param col.tree Colour of the phylogeny edges#
#' @param tip.color Colour of the phylogeny tip labels#
#' @param lwd.bar Width of the bar to summarise age uncertainty, applicable only if plot.type is phylogram and node.method is bar#
#' @param grey.bars Logical. Should grey bars be used to signify time bins, applicable only if add.time.scale is TRUE#
#' @param cex.age Size of the labels for the absolute timescale#
#' @param cex.labels Size of the labels for the geological timescale#
#' @param relative.height the relative height of the timescale labels#
#' @param ntrees For analysis.type mrbayes, the number of independent chains to summarise#
#' @param tip.bar.col The colour of uncertainty around non-contemporary tips#
#' @param burn.in The number of points in the chain to discard for MrBayes and RevBayes analyses#
#' @param distribution.height The relative height of node distributions when plot.type is distributions measured as the relative height of the descendent node#
#' @keywords #
#' @return If plot=TRUE plot of distributions in file 'pdfOutput' written to current working directory#
#' @export#
#' @examples#
#' # example#
#
mcmc.tree.plot <- function(phy, analysis.type="mcmctree", mcmc.chain=NULL, node.ages=NULL, directory.files=NULL, plot.type="phylogram", build.tree=FALSE, node.method="bar", add.time.scale=TRUE, add.abs.time=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, cex.labels=1, relative.height=0.08, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	mb.tree <- TRUE#
	if(match(tolower(analysis.type), "mcmctree") == 1) mb.tree <- FALSE#
	if(mb.tree && plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.files)#
		t.name <- gsub(".con.tre", ".run1.t", directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		phy.data <- read.in.revbayes(directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(node.method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(node.method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(node.method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(node.method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.files)[[1]])#
			path.to.files <- substring(directory.files, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
#' Plot time-scaled phylogenies#
#'#
#' Plot time-scaled phylogenies with node uncertainty and timescale#
#' @param phy A timescaled phylogeny, unless analysis.type="mcmctree" and build.tree=TRUE#
#' @param analysis.type The method used to generate the time-scale tree, one of mcmctree, MrBayes, RevBayes, or User.#
#' @param mcmc.chain The full posterior of age estimates for all nodes (default NULL)#
#' @param node.ages User-supplied node ages applicable for analysis.type user#
#' @param directory.files The directory for files to summarise for MrBayes and RevBayes analyses#
#' @param plot.type The plotting method for the phylogram corresponding to the APE definition. Phylogram is available for all analysis types, but cladogram is only avilable for mcmctree analyses at present. Type distributions plots a phylogram with density distributions on each of the nodes.#
#' @param build.tree Logical. Only applicable to mcmctree analyses, whether to timescale the phylogeny based on the full mcmc chain#
#' @param node.method For plot.type phylogram the method to dispay age uncertainty on each node, either bar, node.length, or full.length.#
#' @param add.time.scale Logical. Adds a timescale to the plotted phylogeny.#
#' @param add.abs.time Logical. Adds an absolute timescale alongside the geological timescale. Only applicable if add.time.scale is TRUE#
#' @param scale.res The geological age designation to add to the plot#
#' @param time.correction Number to place branch lengths and age estimates in absolute time, deafult to one.#
#' @param col.age The colouring of the node.method bars to summarise node age uncertainty#
#' @param tip.lengths Logical. If the tree contains non-present tip ages, the age uncertainty associated with them will be added to the plot#
#' @param cex.tips Size of the phylogeny tip labels#
#' @param show.tip.label Logical. Should the tree tip labels be displayed#
#' @param col.tree Colour of the phylogeny edges#
#' @param tip.color Colour of the phylogeny tip labels#
#' @param lwd.bar Width of the bar to summarise age uncertainty, applicable only if plot.type is phylogram and node.method is bar#
#' @param grey.bars Logical. Should grey bars be used to signify time bins, applicable only if add.time.scale is TRUE#
#' @param cex.age Size of the labels for the absolute timescale#
#' @param cex.labels Size of the labels for the geological timescale#
#' @param relative.height the relative height of the timescale labels#
#' @param ntrees For analysis.type mrbayes, the number of independent chains to summarise#
#' @param tip.bar.col The colour of uncertainty around non-contemporary tips#
#' @param burn.in The number of points in the chain to discard for MrBayes and RevBayes analyses#
#' @param distribution.height The relative height of node distributions when plot.type is distributions measured as the relative height of the descendent node#
#' @keywords #
#' @return If plot=TRUE plot of distributions in file 'pdfOutput' written to current working directory#
#' @export#
#' @examples#
#' # example#
#
mcmc.tree.plot <- function(phy, analysis.type="mcmctree", mcmc.chain=NULL, node.ages=NULL, directory.files=NULL, plot.type="phylogram", build.tree=FALSE, node.method="bar", add.time.scale=TRUE, add.abs.time=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, cex.labels=1, relative.height=0.08, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8) {#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	mb.tree <- TRUE#
	if(is.numeric(match(tolower(analysis.type), "mrbayes"))) mb.tree <- FALSE#
	if(mb.tree && plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.files)#
		t.name <- gsub(".con.tre", ".run1.t", directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		phy.data <- read.in.revbayes(directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(node.method == "full.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
			}#
		if(node.method == "node.length") {#
			polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
		}#
		if(node.method == "bar") {#
			lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
		}#
#
		counter <- 2#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))		#
		if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(node.method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 2#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.files)[[1]])#
			path.to.files <- substring(directory.files, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(node.times)) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			for(k in 1:length(all.nodes)) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col="#00000020", border="#00000070")#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
mcmc.tree.plot(phy, analysis.type="mrbayes", directory.files="/Applications/MrBayes/examples/hymfossil.nex.con.tre", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", lwd.bar=2)
phy.edge <- phy$apePhy$edge#
phy <- phy$apePhy
## set up node ages manually#
all.nodes <- as.numeric(gsub("t_n", "", colnames(mcmc.chain)[2:103]))#
mcmc.chain.age <- mcmc.chain[,2:103]#
node.ages <- vector("list", Nnode(phy))#
names(node.ages)[1:Nnode(phy)] <- c(Ntip(phy) +1, phy.edge[which(phy.edge[,2] > Ntip(phy)),2])#
for(uu in 1:length(all.nodes)) 	node.ages[[uu]] <- mcmc.chain.age[,uu]#
## names(node.ages)[-c(1:Nnode(phy))] <- 1:Ntip(phy)#
## node.ages[-c(1:Nnode(phy))] <- c(0,0)
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
# phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
# mcmctree.posterior <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)#
# mcmctreer.phy <- scan("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre", what="", sep="\t", quiet=TRUE)#
# mcmctree.output <- list(mcmctreer.phy, mcmctree.posterior)#
# names(mcmctree.output) <- c("mcmctreer.phy", "mcmctree.posterior")#
# save(mcmctree.output, file='~/Documents/MCMCTreeR_parent/MCMCTreeR/data/mcmctree.output.RData')#
#
data(mcmctree.output)#
names(mcmctree.output)#
#
phy <- readMCMCTree(mcmctree.output$mcmctreer.phy, from.file=FALSE)#
#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.45, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.45, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="grey40", lwd.bar=2)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="grey40")
node.colours <- rep("#ff008050", Nnode(phy$apePhy))#
node.colours.border <- rep("#ff008090", Nnode(phy$apePhy))#
node.colours[1] <- "#00008050"#
node.colours.border[1] <- "#00008090"#
#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period", "Epoch", "Age"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.tree="grey40", col.age="black", density.col=node.colours, density.border.col=node.colours.border)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.tree="grey40", col.age="black", density.col=node.colours, density.border.col=node.colours.border)
phy.edge <- phy$apePhy$edge#
phy <- phy$apePhy#
mcmc.chain <- mcmctree.output$mcmctree.posterior
## set up node ages manually#
all.nodes <- as.numeric(gsub("t_n", "", colnames(mcmc.chain)[2:Ntip(phy)]))#
mcmc.chain.age <- mcmc.chain[ , 2:Ntip(phy)]#
node.ages <- vector("list", Nnode(phy))#
names(node.ages)[1:Nnode(phy)] <- c(Ntip(phy) +1, phy.edge[which(phy.edge[,2] > Ntip(phy)),2])#
for(uu in 1:length(all.nodes)) 	node.ages[[uu]] <- mcmc.chain.age[,uu]#
names(node.ages)[-c(1:Nnode(phy))] <- 1:Ntip(phy)#
node.ages[-c(1:Nnode(phy))] <- c(0,0)
mcmc.tree.plot(phy=phy, mcmc.chain=mcmctree.output$mcmctree.posterior, analysis.type="user", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.tree="grey40", col.age="black", density.col=node.colours, density.border.col=node.colours.border)
mcmc.tree.plot(phy=phy, node.ages=node.ages, analysis.type="user", cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, build.tree=FALSE, col.tree="grey40", col.age="black", density.col=node.colours, density.border.col=node.colours.border)
names(mcmctree.output)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
data(mcmctree.output)#
attach(mcmctree.output)#
names(mcmctree.output)#
#
phy <- readMCMCTree(mcmctree.output$mcmctreer.phy, from.file=FALSE)#
#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.45, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="grey40", lwd.bar=2)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.45, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="grey40", lwd.bar=2, add.time.scale=FALSE)
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
# phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
# mcmctree.posterior <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)#
# mcmctreer.phy <- scan("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre", what="", sep="\t", quiet=TRUE)#
# mcmctree.output <- list(mcmctreer.phy, mcmctree.posterior)#
# names(mcmctree.output) <- c("mcmctreer.phy", "mcmctree.posterior")#
# save(mcmctree.output, file='~/Documents/MCMCTreeR_parent/MCMCTreeR/data/mcmctree.output.RData')#
#
data(mcmctree.output)#
attach(mcmctree.output)#
names(mcmctree.output)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
phy <- readMCMCTree(mcmctreer.phy, from.file=FALSE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#000080", col.tree="white")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.output$mcmctree.posterior, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="cladogram", cex.age=0.4, cex.labels=0.4, relative.height=0.08, build.tree=FALSE, col.age="#00008020", col.tree="white")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="cladogram", lwd.bar=2, add.time.scale=FALSE, col.tree="white")
?mcmc.tree.plot
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="node.length")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="node.length", col.age="#ff000040")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="full.length", col.age="#ff000040")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="full.length", col.age="#ff000010")
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="full.length", col.age="#ff000002")
analysis.type="mcmctree"; mcmc.chain=NULL; node.ages=NULL; directory.files=NULL; plot.type="phylogram"; build.tree=FALSE; node.method="bar"; add.time.scale=TRUE; add.abs.time=TRUE; scale.res="Epoch"; time.correction=1; col.age="blue"; tip.lengths=FALSE; density.col="#00000050"; density.border.col="#00000080"; cex.tips=1; show.tip.label=TRUE; col.tree="black"; tip.color="black"; lwd.bar=1; grey.bars=TRUE; cex.age=1; cex.labels=1; relative.height=0.08; n.trees=2; tip.bar.col="#ff000050"; burn.in=0.25; distribution.height=0.8#
cex.tips=0.33; time.correction=100; plot.type="phylogram"; lwd.bar=2; add.time.scale=FALSE; node.method="full.length"; col.age="#ff0000"
if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))) {#
		stop("scale.res must be one/combination of 'Eon', 'Period', 'Epoch', or 'Age'")#
	}#
	mb.tree <- TRUE#
	if(is.numeric(match(tolower(analysis.type), "mrbayes"))) mb.tree <- FALSE#
	if(mb.tree && plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.files)#
		t.name <- gsub(".con.tre", ".run1.t", directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		phy.data <- read.in.revbayes(directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	} else {#
		t.depth <- 0#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}
plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)
nodelabels()
plot(phy)
nodelabels()
last.plot.coord$edge[,2]
#' Plot time-scaled phylogenies#
#'#
#' Plot time-scaled phylogenies with node uncertainty and timescale#
#' @param phy A timescaled phylogeny, unless analysis.type="mcmctree" and build.tree=TRUE#
#' @param analysis.type The method used to generate the time-scale tree, one of mcmctree, MrBayes, RevBayes, or User.#
#' @param mcmc.chain The full posterior of age estimates for all nodes (default NULL)#
#' @param node.ages User-supplied node ages applicable for analysis.type user#
#' @param directory.files The directory for files to summarise for MrBayes and RevBayes analyses#
#' @param plot.type The plotting method for the phylogram corresponding to the APE definition. Phylogram is available for all analysis types, but cladogram is only avilable for mcmctree analyses at present. Type distributions plots a phylogram with density distributions on each of the nodes.#
#' @param build.tree Logical. Only applicable to mcmctree analyses, whether to timescale the phylogeny based on the full mcmc chain#
#' @param node.method For plot.type phylogram the method to dispay age uncertainty on each node, either bar, node.length, or full.length.#
#' @param all.nodes If NULL (default) node uncertainty is plotted on all nodes. If node numbers are supplied, only these nodes will be labelled with uncertainty.#
#' @param add.time.scale Logical. Adds a timescale to the plotted phylogeny.#
#' @param add.abs.time Logical. Adds an absolute timescale alongside the geological timescale. Only applicable if add.time.scale is TRUE#
#' @param scale.res The geological age designation to add to the plot can be one or a combination of Eon, Period, Epoch, Age. The order of plot (from bottom to top) is the same as the supplied order. Subsequent arguments add.abs.time and grey.bars are based on the last supplied age designation.#
#' @param time.correction Number to place branch lengths and age estimates in absolute time, deafult to one.#
#' @param col.age The colouring of the node.method bars to summarise node age uncertainty#
#' @param tip.lengths Logical. If the tree contains non-present tip ages, the age uncertainty associated with them will be added to the plot#
#' @param density.col Colour of the node distributions (if analysis.type=distributions)#
#' @param density.border.col Colour of the node distributions (if analysis.type=distributions) borders#
#' @param cex.tips Size of the phylogeny tip labels#
#' @param show.tip.label Logical. Should the tree tip labels be displayed#
#' @param col.tree Colour of the phylogeny edges#
#' @param tip.color Colour of the phylogeny tip labels#
#' @param lwd.bar Width of the bar to summarise age uncertainty, applicable only if plot.type is phylogram and node.method is bar#
#' @param grey.bars Logical. Should grey bars be used to signify time bins, applicable only if add.time.scale is TRUE#
#' @param cex.age Size of the labels for the absolute timescale#
#' @param cex.labels Size of the labels for the geological timescale#
#' @param relative.height the relative height of the timescale labels#
#' @param ntrees For analysis.type mrbayes, the number of independent chains to summarise#
#' @param tip.bar.col The colour of uncertainty around non-contemporary tips#
#' @param burn.in The number of points in the chain to discard for MrBayes and RevBayes analyses#
#' @param distribution.height The relative height of node distributions when plot.type is distributions measured as the relative height of the descendent node#
#' @return If plot=TRUE plot of distributions in file 'pdfOutput' written to current working directory#
#' @export#
#' @examples#
#' # example#
#
mcmc.tree.plot <- function(phy=NULL, analysis.type="mcmctree", mcmc.chain=NULL, node.ages=NULL, directory.files=NULL, plot.type="phylogram", build.tree=FALSE, node.method="bar", all.nodes=NULL, add.time.scale=TRUE, add.abs.time=TRUE, scale.res="Epoch", time.correction=1, col.age="blue", tip.lengths=FALSE, density.col="#00000050", density.border.col="#00000080", cex.tips=1, show.tip.label=TRUE, col.tree="black", tip.color="black", lwd.bar=1, grey.bars=TRUE, cex.age=1, cex.labels=1, relative.height=0.08, n.trees=2, tip.bar.col="#ff000050", burn.in=0.25, distribution.height=0.8, ...) {#
	if(is.na(match(tolower(analysis.type), c("mcmctree", "mrbayes", "revbayes", "user")))) {#
		stop("analysis.type must be one of 'mcmctree', 'mrbayes', 'revbayes', or 'user'")#
	}#
	if(any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))) {#
		stop("scale.res must be one/combination of 'Eon', 'Period', 'Epoch', or 'Age'")#
	}#
	mb.tree <- TRUE#
	if(is.numeric(match(tolower(analysis.type), "mrbayes"))) mb.tree <- FALSE#
	if(mb.tree && plot.type == "distributions" && is.null(mcmc.chain)) stop("The distribution plot.type options needs the full mcmc.chain")#
	if(analysis.type == "mcmctree") {#
		phy.in <- phy#
		phy <- phy.in[[1]]#
		}#
	if(analysis.type == "mrbayes") {#
		phy.data <- read.in.mrbayes(directory.files)#
		t.name <- gsub(".con.tre", ".run1.t", directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "revbayes") {#
		phy.data <- read.in.revbayes(directory.files)#
		phy <- phy.data$phy#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}#
	if(analysis.type == "user") {#
		if(plot.type == "cladogram") stop("sorry plot type 'cladogram' only avilable for mcmctree trees")#
		}	#
	if(add.time.scale) {#
		highest.level <- length(scale.res)#
		check.level <- any(is.na(match(scale.res, c("Eon", "Period", "Epoch", "Age"))))#
		if(is.na(check.level)) stop("scale.res must be one of Eon, Period, Epoch, Age")#
		each.height <- -(relative.height * Ntip(phy)) / highest.level#
		t.depth <- (each.height * highest.level)#
		heights <- seq(from=t.depth, to=0.5, length.out=highest.level + 1)#
	} else {#
		t.depth <- 0#
	}#
	if(analysis.type == "mcmctree") {#
		if(!is.null(mcmc.chain)) {#
			internal.node.local <- which(regexpr("t_n", names(mcmc.chain)) != -1)#
			node.estimates <- mcmc.chain[,internal.node.local] * time.correction#
			phy.matrix <- matrix(NA, ncol=2, nrow=Ntip(phy) * 2 - 2)#
			node.in.ape <- as.numeric(gsub("t_n", "", names(node.estimates)))#
			hpd.ages <- apply(node.estimates, 2, function(x) HPDinterval(as.mcmc(x))) #
			mean.ages <- apply(node.estimates, 2, function(x) mean(x))#
			max.ages <- apply(node.estimates, 2, function(x) max(x))#
			end.age <- hpd.ages[2,1]#
			if(build.tree) {#
				for(ii in 1:length(mean.ages)) phy.matrix[which(node.in.ape[ii] == phy$edge[,1]), 1] <- mean.ages[ii]#
				ext.node <- which(phy$edge[,2] > Ntip(phy))#
				phy.matrix[ext.node, 2] <- mean.ages[-1]#
				phy.matrix[-ext.node, 2] <- 0#
				b.lengths <- phy.matrix[,1] - phy.matrix[,2]#
				phy$edge.length <- b.lengths#
				phy$root.edge <- end.age - phy.matrix[1,1]#
			} else {#
				phy$edge.length <- phy$edge.length * time.correction#
				phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
				}#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		} else {#
			phy$edge.length <- phy$edge.length * time.correction#
			phy.in$nodeAges <- phy.in$nodeAges * time.correction#
			hpd.ages <- t(phy.in$nodeAges[,-1])#
			mean.ages <- phy.in$nodeAges[,1]#
			end.age <- hpd.ages[2,1]#
			node.in.ape <- as.numeric(rownames(phy.in$nodeAges))#
			ext.node <- which(phy$edge[,2] > Ntip(phy))#
			phy$root.edge <- end.age - mean.ages[1]#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "mrbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		tip.range <- sapply(phy.data$tip.ages[,"age_95%HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		}#
	if(analysis.type == "revbayes") {#
		node.hpd <- phy.data#
		hpd.ages <- sapply(phy.data$node.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(phy.data$node.ages[,"node.name"])#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(colnames(phy.data$tip.ages) == "age_95%_HPD") {#
			tip.range <- sapply(phy.data$tip.ages[,"age_95%_HPD"], function(xx) as.numeric(strsplit(xx, ",")[[1]]))#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
	}#
	if(analysis.type == "user") {#
		node.ages <- lapply(node.ages, function(x) x * time.correction)#
		phy$edge.length <- phy$edge.length * time.correction#
		hpd.ages <- sapply(node.ages, function(xx) HPDinterval(as.mcmc(xx)))#
		end.age <- hpd.ages[2,1]#
		node.in.ape <- as.numeric(names(node.ages))#
		phy$root.edge <- end.age - nodeTimes(phy)[1,1]#
		if(length(node.ages) > (Nnode(phy) + 1)) {#
			tip.range <- hpd.ages[-c(1:(Nnode(phy) + 1))]#
		} else {#
			tip.range <- matrix(0, nrow=2, ncol=Ntip(phy))#
		}#
		node.estimates <- node.ages#
	}#
	###########################################
	############ plot functions ###############
	###########################################
	############    phylogram   ###############
	if(plot.type == "phylogram") {#
		plot.phylo(ladderize(phy), type="phylogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color, ...)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)					#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		if(is.null(all.nodes)) {#
			ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
			if(length(col.age) < length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
			if(node.method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[1], border=FALSE)#
				}#
			if(node.method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[1], border=FALSE)#
			}#
			if(node.method == "bar") {#
				lines(c(xx[1], xx[2]), rep(structure[1,1], 2), col=col.age[1], lwd=lwd.bar)#
			}#
		} else {#
			ext.node <- match(all.nodes, last.plot.coord$edge[,2])#
			if(length(col.age) == length(ext.node)) col.age <- rep(col.age, length(ext.node) + 1)#
			}#
		counter <- 2#
		for(uu in ext.node) {#
			match.nodes <- last.plot.coord$edge[uu,2]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- mean.ages[,location.here]#
			match.edges <- range(which(last.plot.coord$edge[,1] == last.plot.coord$edge[uu,2]))#
			if(node.method == "full.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), matrix(c(0, 0, Ntip(phy), Ntip(phy)), ncol=2), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "node.length") {#
				polygon(c(xx[1], xx[2], xx[2], xx[1]), rbind(structure[match.edges,2], structure[match.edges,2]), col=col.age[counter], border=FALSE)#
				}#
			if(node.method == "bar") {#
				lines(xx, rep(structure[uu,2], 2), col=col.age[counter], lwd=lwd.bar)#
				}	#
			counter = counter + 1#
		}#
		if(tip.lengths) {#
			phy.to <- nodeTimes(phy)[,2]#
			tip.here <- which(phy$edge[,2] <= Ntip(phy))#
			tip.to.label <- tip.here[which(nodeTimes(phy)[tip.here,2] > 0.01)]#
			for(uu in phy$edge[tip.to.label,2] ) {#
				match.nodes <- Nnode(phy) + uu#
				xx <- mean.ages[,match.nodes]#
				match.edges <- last.plot.coord$edge[uu,1]#
				yy.loc <- last.plot.coord$yy[uu]#
				lines(xx, rep(yy.loc, 2), col=tip.bar.col, lwd=lwd.bar)#
			}#
		}#
	}#
	############    cladogram   ###############
#
	if(plot.type == "cladogram") {#
		plot.phylo(ladderize(phy), type="cladogram", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color, ...)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
		ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
		structure <- cbind(int, ext)#
		node.in.ape <- c(node.in.ape, 1:Ntip(phy))#
		mean.ages <- cbind(end.age - hpd.ages, end.age - tip.range)#
		match.nodes <- last.plot.coord$edge[1,1]#
		location.here <- match(match.nodes, node.in.ape)#
		xx <- mean.ages[,location.here]#
		match.edges <- which(last.plot.coord$edge[,1] == Ntip(phy) + 1)#
		match.nodes <- last.plot.coord$edge[1, 1]#
		location.here <- which(match.nodes == last.plot.coord$edge[,1])#
		xx <- mean.ages[,1]#
		ext.node <- which(last.plot.coord$edge[,2] > Ntip(phy))#
		if(length(col.age) < dim(last.plot.coord$edge)[1]) {#
			col.age <- rep(col.age, dim(last.plot.coord$edge)[1])#
			lines(xx, rep(structure[1,1], 2), lwd=lwd.bar, col=col.age[1])#
		}		#
		counter <- 1#
		for(uu in 1:dim(last.plot.coord$edge)[1]) {#
			match.nodes <- last.plot.coord$edge[uu, ]#
			location.here <- match(match.nodes, node.in.ape)#
			xx <- c(mean.ages[,location.here])#
			polygon(c(xx[1], xx[3], xx[4], xx[2]), c(structure[uu,], rev(structure[uu,])), col=col.age[counter], border=FALSE)#
			counter <- counter + 1#
			}#
		}#
	############  distributions   ###############
	if(plot.type == "distributions") {#
		plot.phylo(ladderize(phy), type="p", edge.col=col.tree, root.edge=TRUE, y.lim=c(t.depth, Ntip(phy)), cex=cex.tips, show.tip.label=show.tip.label, tip.color=tip.color, ...)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		last.plot.coord <- get("last_plot.phylo", envir = .PlotPhyloEnv)#
		if(analysis.type == "mrbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.nexus(gsub("run1", paste0("run", kk), t.name))#
				tre.in <- scan(gsub("run1", paste0("run", kk), t.name), what="", sep="\n", quiet=TRUE)#
				start.names <- which(regexpr("translate", tre.in) != -1) + 1#
				end.names <- which(regexpr("tree gen", tre.in) != -1)[1] - 1#
				names.on.tree <- sapply(tre.in[start.names:end.names], function(xx) {#
					xx <- gsub(",", "", tail(strsplit(xx, " ")[[1]], 1))#
					xx <- gsub(";", "", xx)#
					}#
				)#
				clock.rate.in <- unlist(gregexpr("&clockrate", tre.in))#
				clock.rate.loc <- which(clock.rate.in != -1)#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				clock.rate.loc <- clock.rate.loc[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.here <- tre.in[clock.rate.loc[y]]#
					new.string <- substring(tree.here, regexpr("&clockrate", tree.here) + 1, )	#
					new.string <- substring(new.string, 1, regexpr("[]]", new.string) - 1)	#
					clock.rate <- as.numeric(strsplit(new.string, "=")[[1]][2])#
					tree.in <- read.tree(text=tree.here)#
					tree.in$tip.label <- as.character(names.on.tree[as.numeric(tree.in$tip.label)])#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in) / clock.rate#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
			len.all.nd <- length(all.nodes)#
			if(length(density.col) < len.all.nd) density.col <- rep(density.col, len.all.nd)#
			if(length(density.border.col) < len.all.nd) density.border.col <- rep(density.border.col, len.all.nd)#
			for(k in 1:len.all.nd) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col=density.col[k], border=density.border.col[k])#
				}#
			}#
		if(analysis.type == "revbayes") {#
			internal.nodes <- unique(phy$edge[,1])#
			node.times <- vector("list", length(internal.nodes))#
			slash <- max(gregexpr("/", directory.files)[[1]])#
			path.to.files <- substring(directory.files, 1, slash)#
			log.files <- list.files(path=path.to.files, pattern=".trees")#
			n.trees <- length(log.files)#
			for(kk in 1:n.trees) {#
				tre.in.ape <- read.tree(paste0(path.to.files, "/", log.files[kk]))#
				ceiling.rm <- ceiling(length(tre.in.ape) * burn.in)#
				tre.in.ape <- tre.in.ape[-c(1:ceiling.rm)]#
				for(y in 1:length(tre.in.ape)) {#
					tree.in <- tre.in.ape[[y]]#
					tree.edge.unique <- unique(tree.in$edge[,1])#
					node.times.now <- nodeTimes(tree.in)#
					parts <- prop.part(tree.in, phy)#
					match.on.tree <- which(attributes(parts)$number == 2)#
					for(ii in 1:length(match.on.tree)) {#
						name.now <- parts[[match.on.tree[ii]]]#
						five <- match(tree.edge.unique[match.on.tree[ii]], tree.in$edge[,1])#
						node.time.add <- node.times.now[five, 1]#
						names.now <- attributes(parts)$labels[name.now]#
						mrca.now <- getMRCA(phy, names.now)#
						mrca.store <- match(mrca.now, internal.nodes)#
						node.times[[mrca.store]] <- c(node.times[[mrca.store]], node.time.add)#
					}#
				}#
			}#
			names(node.times) <- internal.nodes#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			len.all.nd <- length(all.nodes)#
			if(length(density.col) < len.all.nd) density.col <- rep(density.col, len.all.nd)#
			if(length(density.border.col) < len.all.nd) density.border.col <- rep(density.border.col, len.all.nd)#
			for(k in 1:len.all.nd) {#
				location.here <- match(as.numeric(names(node.times)[k]), node.in.ape)#
				lower.hpd <- hpd.ages[1, location.here]#
				upper.hpd <- hpd.ages[2, location.here]#
				mcmc.hpd <- node.times[[k]][intersect(which(node.times[[k]] >= lower.hpd), which(node.times[[k]] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col=density.col[k], border=density.border.col[k])#
				}#
			}	#
#
		if(analysis.type == "mcmctree") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]	#
			len.all.nd <- length(all.nodes)#
			if(length(density.col) < len.all.nd) density.col <- rep(density.col, len.all.nd)#
			if(length(density.border.col) < len.all.nd) density.border.col <- rep(density.border.col, len.all.nd)#
			for(k in 1:len.all.nd) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				mcmc.hpd <- node.estimates[,k][intersect(which(node.estimates[,k] >= lower.hpd), which(node.estimates[,k] <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(all.nodes[k] == last.plot.coord$edge[,1])])	#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col=density.col[k], border=density.border.col[k])#
				}#
			}#
		if(analysis.type == "user") {#
			all.nodes <- (Ntip(phy) + 1 ):(Nnode(phy) + Ntip(phy))#
			int <- last.plot.coord$yy[last.plot.coord$edge[,1]]#
			ext <- last.plot.coord$yy[last.plot.coord$edge[,2]]#
			len.all.nd <- length(all.nodes)#
			if(length(density.col) < len.all.nd) density.col <- rep(density.col, len.all.nd)#
			if(length(density.border.col) < len.all.nd) density.border.col <- rep(density.border.col, len.all.nd)#
			for(k in 1:len.all.nd) {#
				lower.hpd <- hpd.ages[1, k]#
				upper.hpd <- hpd.ages[2, k]#
				node.now <- node.estimates[[k]]#
				mcmc.hpd <- node.now[intersect(which(node.now >= lower.hpd), which(node.now <= upper.hpd))]#
				mcmc.den <- density(mcmc.hpd)#
				xx <- last.plot.coord$xx[1] - mcmc.den$x#
				lower.y <- last.plot.coord$yy[all.nodes[k]]#
				upper.y <- max(ext[which(last.plot.coord$edge[,1] == all.nodes[k])])#
				scale.den <- (upper.y - lower.y) * distribution.height#
				y.scale <- mcmc.den$y * (scale.den / max(mcmc.den$y))#
				yy <- y.scale + lower.y#
				polygon(xx, yy, col=density.col[k], border=density.border.col[k])#
				}#
			}#
		}#
	###########################################
	############ add time scale ###############
	###########################################
#
		if(add.time.scale) {#
			xlimit <- last.plot.coord$xx#
			total.length <- max.xlim <- max(xlimit)#
			eon.bin <- .bincode(max.xlim, Eon)#
			period.bin <- .bincode(max.xlim, Period)#
			epoch.bin <- .bincode(max.xlim, Epoch)#
			if(is.na(epoch.bin)) epoch.bin <- length(Epoch)#
			age.bin <- .bincode(max.xlim, Age)#
			if(is.na(age.bin)) age.bin <- length(Age)#
			bin.eon <- max.xlim - c(Eon[1:eon.bin], max.xlim)#
			bin.period <- max.xlim - c(Period[1:period.bin], max.xlim)#
			bin.epoch <- max.xlim - c(Epoch[1:epoch.bin], max.xlim)#
			bin.age <- max.xlim - c(Age[1:age.bin], max.xlim)#
				plot.bar <- function(bin.data, data.colour, name.data, ht, ht.pl, grey.line=FALSE, cex.labels.int) {#
				names.in <- name.data[1:(length(bin.data) - 1)]#
				for(u in 2:length(bin.data)) {#
					polygon(rep(bin.data[(u):(u-1)], each=2),c(heights[ht:ht.pl], rev(heights[ht:ht.pl])), xpd=TRUE, col=data.colour[c(u-1)], border=FALSE)#
					bin.length <- abs(diff(bin.data[(u):(u-1)]))#
					percent <- bin.length / total.length#
					if(percent >= 0.4) {#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), names.in[c(u-1)], cex=cex.labels.int)#
					} #
					if(percent >= 0.1 && percent < 0.4) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1:2], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}#
					if(percent < 0.1 && percent >= 0.04) {#
						name.in <- paste0(paste0(strsplit(names.in[c(u-1)], "")[[1]][1], collapse=""), ".")#
						text(mean(bin.data[(u):(u-1)]), mean(heights[ht:ht.pl]), name.in, cex=cex.labels.int)#
					}	#
					if(grey.line) {#
						if(u %% 2 == 0) polygon(rep(bin.data[(u):(u-1)], each=2),c(0.5, Ntip(phy), Ntip(phy), 0.5), xpd=TRUE, col="#00000020", border=FALSE)#
					}	#
				}#
			}#
			plot.time.scale <- function(level, start.one, end.one, time.check=FALSE, grey.now=FALSE, cex.age.int) {#
				if(level == "Eon") {#
					plot.bar(bin.eon, Eon.colour, names(Eon.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Eon", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.eon, labels=signif(total.length-bin.eon, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Period") {#
					plot.bar(bin.period, Period.colour, names(Period.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Period", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.period, labels=signif(total.length-bin.period, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Epoch") {#
					plot.bar(bin.epoch, Epoch.colour, names(Epoch.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Epoch", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.epoch, labels=signif(total.length-bin.epoch, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
				if(level == "Age") {#
					plot.bar(bin.age, Age.colour, names(Age.colour),start.one,end.one, grey.line=grey.now, cex.labels.int=cex.labels)#
					text(total.length, mean(heights[start.one:end.one]), "Age", pos=4, font=3, cex=cex.labels)#
					if(time.check) {#
						axis(3, at=bin.age, labels=signif(total.length-bin.age, 2), line=-0.6, lwd=0, lwd.ticks=0.7, mgp=c(3, 0.5, 0), col="black", cex.axis=cex.age.int)#
						mtext("Age (Ma)", 3, at=total.length+0.1, font=3, xpd=TRUE, line=1, col="black", cex=cex.labels)#
					}#
				}#
			}#
			start.one <- 1#
			end.one <- 2#
			if(length(add.abs.time) == 1 && add.abs.time[1] == TRUE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				add.abs.time[length(add.abs.time)] <- TRUE#
				}#
			if(length(add.abs.time) == 1 && add.abs.time[1] == FALSE) {#
				add.abs.time <- rep(FALSE, length(scale.res))#
				}#
			if(grey.bars) {#
				grey.now.int <- rep(FALSE, length(scale.res))#
				if(!any(add.abs.time)) {#
					add.time <- length(scale.res)#
					} else {#
					add.time <- which(add.abs.time)	#
					}#
				grey.now.int[add.time] <- TRUE#
			}#
			for(uu in 1:length(scale.res)) {#
				plot.time.scale(scale.res[uu], time.check=add.abs.time[uu], start.one=start.one, end.one=end.one, grey.now=grey.now.int[uu], cex.age.int=cex.age)#
				start.one <- start.one + 1#
				end.one <- end.one + 1#
				}#
		}#
	}
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
# phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
# mcmctree.posterior <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)#
# mcmctreer.phy <- scan("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre", what="", sep="\t", quiet=TRUE)#
# mcmctree.output <- list(mcmctreer.phy, mcmctree.posterior)#
# names(mcmctree.output) <- c("mcmctreer.phy", "mcmctree.posterior")#
# save(mcmctree.output, file='~/Documents/MCMCTreeR_parent/MCMCTreeR/data/mcmctree.output.RData')#
#
data(mcmctree.output)#
attach(mcmctree.output)#
names(mcmctree.output)
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="bar", col.age="navy", no.margin=TRUE)
phy <- readMCMCTree(mcmctreer.phy, from.file=FALSE)
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="bar", col.age="navy", no.margin=TRUE)
?plot.phylo
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
# phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
# mcmctree.posterior <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)#
# mcmctreer.phy <- scan("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre", what="", sep="\t", quiet=TRUE)#
# mcmctree.output <- list(mcmctreer.phy, mcmctree.posterior)#
# names(mcmctree.output) <- c("mcmctreer.phy", "mcmctree.posterior")#
# save(mcmctree.output, file='~/Documents/MCMCTreeR_parent/MCMCTreeR/data/mcmctree.output.RData')#
#
data(mcmctree.output)#
attach(mcmctree.output)#
names(mcmctree.output)
phy <- readMCMCTree(mcmctreer.phy, from.file=FALSE)
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="none", col.age="navy", no.margin=TRUE)
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, node.method="none", col.tree="grey40", label.offset=4, no.margin=TRUE)
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, node.method="none", col.tree="grey40", label.offset=4, no.margin=TRUE)
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period", "Epoch", "Age"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, node.method="none", col.tree="grey40", label.offset=4, no.margin=TRUE)
mcmc.tree.plot(phy, cex.tips=0.33, time.correction=100, scale.res=c("Eon", "Period", "Epoch", "Age"), plot.type="phylogram", cex.age=0.4, cex.labels=0.5, relative.height=0.08, node.method="none", col.tree="grey40", label.offset=4, no.margin=TRUE)
rm(list=ls(all=TRUE))#
library(MCMCTreeR)#
library(coda)#
library(motmot.2.0)#
#
# phy <- readMCMCTree("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre")#
# mcmctree.posterior <- read.table("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/mcmc.out", header=TRUE)#
# mcmctreer.phy <- scan("~/Documents/uob/Postdoc/WickettTrees/datingAnalyses/results/alternativeTopology1701170/monophyletic/FigTree.tre", what="", sep="\t", quiet=TRUE)#
# mcmctree.output <- list(mcmctreer.phy, mcmctree.posterior)#
# names(mcmctree.output) <- c("mcmctreer.phy", "mcmctree.posterior")#
# save(mcmctree.output, file='~/Documents/MCMCTreeR_parent/MCMCTreeR/data/mcmctree.output.RData')#
#
data(mcmctree.output)#
attach(mcmctree.output)#
names(mcmctree.output)#
phy <- readMCMCTree(mcmctreer.phy, from.file=FALSE)#
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, add.time.scale=FALSE, node.method="bar", col.age="navy", no.margin=TRUE)#
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="cladogram", lwd.bar=2, add.time.scale=FALSE, node.method="node.length", col.age="#008b0040")#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, col.tree="grey40", add.time.scale=FALSE, no.margin=TRUE, label.offset=4, density.col = "#00000050", density.border.col = "#00000080")
par(mfrow=c(1,3))#
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="phylogram", lwd.bar=2, scale.res=c("Eon", "Period"), node.method="bar", col.age="navy", no.margin=TRUE)#
mcmc.tree.plot(phy, analysis.type="mcmctree", cex.tips=0.33, time.correction=100, plot.type="cladogram", lwd.bar=2, scale.res=c("Eon", "Period"), node.method="node.length", col.age="#008b0040")#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.4, cex.labels=0.5, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#00000050", density.border.col = "#00000080")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.5, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#00000050", density.border.col = "#00000080")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.5, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000050", density.border.col = "#ff000090")
par(mfrow=c(1,1))#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.5, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff000080")
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.33, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff000080")
par(mfrow=c(1,1))#
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff000080")
args(mcmc.tree.plot)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff000080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff030080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#ff234080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#ff000030", density.border.col = "#008b0080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#008b0050", density.border.col = "#008b0080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#00FFFF50", density.border.col = "#00FFFF80",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#00808050", density.border.col = "#00808080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#80008050", density.border.col = "#80008080",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#4B008250", density.border.col = "#4B008280",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#E6E6FA50", density.border.col = "#E6E6FA80",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#E6E6FA90", density.border.col = "#E6E6FA",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#E6E6FA99", density.border.col = "#E6E6FA",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#DDA0DD99", density.border.col = "#DDA0DD",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#DDA0DD70", density.border.col = "#DDA0DD90",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="distributions", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, density.col = "#4169E170", density.border.col = "#4169E190",  label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="cladogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="grey40", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, age.col = "#4169E170", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="cladogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="#4169E1", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "#4169E170", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="cladogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="##008b00", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "##008b0070", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="cladogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="#008b00", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "#008b0070", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="p", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="black", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "navy", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="phylogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="black", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "navy", label.timescale.names=TRUE)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="phylogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="black", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "navy", label.timescale.names=TRUE, lwd.bar=2)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="phylogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="black", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "#00008090", label.timescale.names=TRUE, lwd.bar=2)
mcmc.tree.plot(phy, mcmc.chain=mcmctree.posterior, cex.tips=0.35, time.correction=100, plot.type="phylogram", cex.age=0.7, cex.labels=0.7, relative.height=0.08, col.tree="black", scale.res=c("Eon", "Period"), no.margin=TRUE, label.offset=4, col.age = "#00008098", label.timescale.names=TRUE, lwd.bar=2)
